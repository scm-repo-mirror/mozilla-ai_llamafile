diff --git a/tools/server/server.cpp b/tools/server/server.cpp
index f5089bef2..f9e88d7bd 100644
--- a/llama.cpp/tools/server/server.cpp
+++ b/llama.cpp/tools/server/server.cpp
@@ -30,6 +30,10 @@
 #include <unordered_map>
 #include <unordered_set>

+#ifdef COSMOCC
+#include <cosmo.h>
+#endif
+
 using json = nlohmann::ordered_json;

 constexpr int HTTP_POLLING_SECONDS = 1;
@@ -2074,7 +2079,7 @@ struct server_queue {
     }

     // Add a new task, but defer until one slot is available
-    void defer(server_task && task) {
+    void defer_task(server_task && task) {
         std::unique_lock<std::mutex> lock(mutex_tasks);
         QUE_DBG("defer task, id = %d\n", task.id);
         queue_tasks_deferred.push_back(std::move(task));
@@ -3350,14 +3355,14 @@ struct server_context {
                     if (slot == nullptr) {
                         // if no slot is available, we defer this task for processing later
                         SRV_DBG("no slot is available, defer task, id_task = %d\n", task.id);
-                        queue_tasks.defer(std::move(task));
+                        queue_tasks.defer_task(std::move(task));
                         break;
                     }

                     if (slot->is_processing()) {
                         // if requested slot is unavailable, we defer this task for processing later
                         SRV_DBG("requested slot is unavailable, defer task, id_task = %d\n", task.id);
-                        queue_tasks.defer(std::move(task));
+                        queue_tasks.defer_task(std::move(task));
                         break;
                     }

@@ -3443,7 +3448,7 @@ struct server_context {
                     if (slot->is_processing()) {
                         // if requested slot is unavailable, we defer this task for processing later
                         SRV_DBG("requested slot is unavailable, defer task, id_task = %d\n", task.id);
-                        queue_tasks.defer(std::move(task));
+                        queue_tasks.defer_task(std::move(task));
                         break;
                     }

@@ -3481,7 +3486,7 @@ struct server_context {
                     if (slot->is_processing()) {
                         // if requested slot is unavailable, we defer this task for processing later
                         SRV_DBG("requested slot is unavailable, defer task, id_task = %d\n", task.id);
-                        queue_tasks.defer(std::move(task));
+                        queue_tasks.defer_task(std::move(task));
                         break;
                     }

@@ -3530,7 +3535,7 @@ struct server_context {
                     if (slot->is_processing()) {
                         // if requested slot is unavailable, we defer this task for processing later
                         SRV_DBG("requested slot is unavailable, defer task, id_task = %d\n", task.id);
-                        queue_tasks.defer(std::move(task));
+                        queue_tasks.defer_task(std::move(task));
                         break;
                     }

@@ -4223,6 +4228,15 @@ struct server_context {
                 if (slot.state == SLOT_STATE_PROCESSING_PROMPT || slot.state == SLOT_STATE_DONE_PROMPT) {
                     if (slot.task->params.stream && slot.task->params.return_progress) {
                         send_partial_response(slot, {}, true);
+
+                        // llamafile START
+                        // keeping n_batch_sleep_ms from mmojo-server
+                        if (params_base.n_batch_sleep_ms > 0) {
+                            SLT_INF(slot, "Starting sleep %d ms after batch.\n", params_base.n_batch_sleep_ms);
+                            std::this_thread::sleep_for(std::chrono::milliseconds(params_base.n_batch_sleep_ms));
+                            SLT_INF(slot, "%s", "Finished sleep after batch.\n");
+                        }
+                        // llamafile END
                     }
                 }

@@ -4440,6 +4518,10 @@ inline void signal_handler(int signal) {
 }

 int main(int argc, char ** argv) {
+    #ifdef COSMOCC
+    argc = cosmo_args("/zip/.args", &argv);
+    #endif
+
     // own arguments required by this example
     common_params params;

